# **CS Study** - Section023 디자인패턴

## ✏️ Study

## 💡 디자인패턴의 개요

### 디자인패턴(Design Pattern)이란?

- 코드를 작성하는 수준의 세부적인 구현 방안을 설계할 때 참조할 수 있는 해결 방식/예제
    - 코드 작성 수준 : 각 모듈의 세분화된 역할, 모듈들 간의 인터페이스 등
- 구성 : 문제 및 배경, 실제 적용된 사례, 재사용이 가능한 샘플 코드 등
- “바퀴를 다시 발명하지 마라(Don’t reinvent the wheel)”
    - 개발 과정 중에 문제가 발생하면 → 새로 해결책 구상X
    - 문제에 해당하는 디자인 패턴을 참고하여 적용하기
- 한 패턴이 유사한 형태의 다른 패턴으로 변화될 수 있음
    - 한 패턴에 변형을 가하거나
    - 특정 요구사항을 반영할 시
- GoF(Gang of Four)라고 불리는 사람 4명이 처음으로 구체화/체계화함
- 유형에 따른 분류 (총 23개)
    - 생성 패턴 5개
    - 구조 패턴 7개
    - 행위 패턴 11개

### 아키텍처 패턴 vs 디자인 패턴

- 공통점 : 소프트웨어 설계를 위한 참조 모델
- 차이점
    
    
    | 아키텍처 패턴 | 디자인 패턴 |
    | --- | --- |
    | 상위 수준 설계에 사용 | 하위 수준 설계에 사용 |
    | 전체 시스템 구조 설계 | 서브시스템(컴포넌트)과 그 관계 설계 |
    |  | 특정 아키텍처 패턴을 구현할 때 유용하게 사용됨 |

## 💡 디자인 패턴 사용의 장/단점

### 장점

- 범용적인 코딩 스타일 → 구조 파악 쉬움
- 객체지향 설계 및 구현의 생산성을 높임
- 검증된 구조의 재사용 → 개발 시간과 비용 절약
- 개발자 간의 원활한 의사소통 가능
- 설계 변경 요청에 대한 유연한 대처 가능

### 단점

- 초기 투자 비용이 부담됨
- 객체지향 기반의 설계와 구현을 다룸 → 다른 기반(ex. 절차지향)의 애플리케이션 개발에는 적합X

## 💡 생성 패턴

### 생성 패턴(Creational Pattern)이란?

- 객체의 생성과 관련된 패턴
- 총 5개의 패턴
- 객체의 생성과 참조 과정을 캡슐화함
    - 객체가 생성되거나 변경되어도 프로그램의 구조에 영향을 크게 받지 않음
    - 프로그램에 유연성을 더해줌

### 생성 패턴의 종류 (5가지)

| 추상 팩토리
(Abstract Factory) | - 구체적인 클래스에 의존X
- 인터페이스를 통해 서로 연관&의존하는 객체들의 그룹으로 생성하여 추상적으로 표현함
- 연관된 서브 클래스를 묶어 한 번에 교체 가능 |
| --- | --- |
| 빌더(Builder) | - 작게 분리된 인스턴스를 건축 하듯이 조합하여 객체를 생성함
- 객체의 생성 과정과 표현 방법을 분리함
- 동일한 객체 생성에서도 서로 다른 결과를 만들어 낼 수 있음  |
| 팩토리 메소드
(Factory Method) | - 객체 생성을 서브 클래스에서 처리하도록 분리하여 캡슐화한 패턴
- 상위 클래스에서 인터페이스만 정의하고, 실제 생성은 서브 클래스가 담당함
- 가상 생성자(Virtual Constructor) 패턴이라고도 부름 |
| 프로토타입(Prototype) | - 원본 객체를 복제하는 방법으로 객체를 생성함
- 일반적인 방법으로 객체를 생성함
- 비용이 큰 경우 주로 이용하는 패턴 |
| 싱글톤(Singleton) | - 하나의 객체를 생성 시 생성된 객체를 어디서든 참조할 수 있지만, 여러 프로세스가 동시 참조 불가능
- 클래스 내에서 인스턴스가 하나뿐임을 보장함
- 불필요한 메모리 낭비를 최소화하기 위해 사용 |

### 생성 패턴 5가지 쉽게 외우기

- 추상 팩토리 : 서로 다른 부품을 조립만 하는 `조립공장(Factory)`
- 빌더 : `건축가(Builder)` 가 블록을 조립하는 모습
- 팩토리 메소드 : 부품~완성품까지 통째로 찍어내는 `공장(Factory)`
    - == `가상 생성자(Virtual Constructor)`
- 프로토타입 : `원형(Prototype)` 을 두고 복제품을 만드는 것
- 싱글톤 : 식당에서 누구나 사용할 수 있지만 `하나뿐(Singleton)인 정수기`

## 💡 구조 패턴

### 구조 패턴(Structural Pattern)이란?

- 클래스나 객체들을 조합하여 더 큰 구조로 만들 수 있게 해주는 패턴
- 총 7개 패턴
- 구조가 복잡한 시스템을 개발하기 쉽게 도와줌

### 구조 패턴의 종류 7가지

| 어댑터(Adapter) | - 호환성이 없는 클래스들의 인터페이스를 다른 클래스가 이용할 수 있도록 변환해주는 패턴
- 기존의 클래스를 이용하고 싶지만 인터페이스가 일치하지 않을 때 이용 |
| --- | --- |
| 브리지(Bridge) | - 구현부에서 추상층을 분리 → 서로가 독립적으로 확장할 수 있도록 구성한 패턴
- 기능과 구현을 2개의 별도 클래스로 구현 |
| 컴포지트(Composite) | - 여러 객체를 가진 복합 객체와 단일 객체를 구분 없이 다루고자 할 때 사용하는 패턴
- 객체들을 트리 구조 로 구성 → 복합 객체 안에 복합 객체가 포함되는 구조 구현(ex. 디렉토리 안에 디렉토리) |
| 데코레이터(Decorator) | - 객체 간의 결합 → 능동적으로 기능을 확장할 수 있는 패턴
- 임의의 객체에 부가적인 기능을 추가하기 위해 다른 객체들을 덧붙이는 방식으로 구현함 |
| 퍼싸드(Facade) | - 복잡한 서브 클래스들을 피해 더 상위에 인터페이스를 구성하는 패턴
- 서브 클래스들의 기능을 간편하게 사용할 수 있도록 함
- 서브 클래스들 사이의 통합 인터페이스를 제공하는 Wrapper 객체가 필요함 |
| 플라이웨이트(Flyweight) | - 인스턴스가 필요할 때마다 매번 생성X
- 인스턴스를 가능한 한 공유해서 사용함 → 메모리 절약
- 다수의 유사 객체를 생성하거나 조작할 때 유용함 |
| 프록시(Proxy) | - 접근이 어려운 객체와 해당 객체에 연결하려는 객체 사이에서 인터페이스 역할을 수행하는 패턴
- 네트워크 연결, 메모리의 대용량 객체로의 접근 등에 주로 이용 |

### 구조 패턴 7가지 쉽게 외우기

- 어댑터 : 전압을 맞춰주는 `변압기(Adapter)`
- 브리지 : 두 섬을 연결하는 `다리(Bridge)`
- 컴포지트 : 폴더와 파일을 `합성(Composite)` 한 것
- 데코레이터 : 온갖 것으로 `장식된(Decorator)` 눈사람
- 퍼싸드 : `외부(Facade)의 리모컨` 버튼만으로 복잡한 명령들을 간단하게 수행하는 것
- 플라이웨이트 : 부담을 `가볍게(Flyweight)` 하기 위해 물품을 공유하는 것
- 프록시 : 내가 하기 어려운 법률업무를 `대리(Proxy)` 해주는 변호사

## 💡 행위 패턴

### 행위 패턴(Behavioral Pattern)이란?

- 클래스나 객체들이 서로 상호작용하는 방법이나 책임 분배 방법을 정의하는 패턴
- 총 11개의 패턴
- 하나의 객체로 수행할 수 없는 작업 → 여러 객체로 분배
    - 결합도를 최소화할 수 있도록 도와줌

### 행위 패턴의 종류 11가지

| 책임 연쇄
(Chain of Responsibility) | - 요청을 처리할 수 있는 객체가 2개 이상 존재할 때
- 요청을 한 객체가 처리하지 못하면 다음 객체로 넘어가는 형태
- 요청을 처리할 수 있는 각 객체들이 고리(Chain)으로 묶여 있음 → 요청이 해결될 때까지 고리를 따라 책임이 넘어감 |
| --- | --- |
| 커맨드(Command) | - 요청을 객체의 형태로 캡슐화함
-  재이용하거나 취소할 수 있도록 요청에 필요한 정보를 저장하거나 로그에 남김
- 요청에 사용되는 각종 명령어들을 추상 클래스와 구체 클래스로 분리하여 단순화함 |
| 인터프리터(Interpreter) | - 언어에 문법 표현을 정의하는 패턴
- SQL이나 통신 프로토콜 등을 개발할 때 사용 |
| 반복자(Iterator) | - 접근이 잦은 객체(ex. 자료구조)에 대해 동일한 인터페이스를 사용하도록 함
- 내부 표현 방법의 노출 없이 순차적인 접근이 가능 |
| 중재자(Mediator) | - 수많은 객체들 간의 복잡한 상호작용(interface)을 캡슐화하여 객체로 정의하는 패턴
- 객체 사이의 의존성을 줄임 → 결합도를 감소시킴
- 중재자 역할 : 객체 간의 통제와 지시 |
| 메멘토(Memento) | - 특정 시점에서의 객체 내부 상태를 객체화함
- 이후 요청에 따라 객체를 해당 시점의 상태로 돌릴 수 있는 기능 제공
- 되돌리기 기능(ex. ctrl+z)을 개발할 때 사용 |
| 옵서버(Observer) | - 한 객체의 상태가 변화 → 객체에 상속되어 있는 다른 객체들에게 변화된 상태를 전달
- 주로 분산된 시스템 간에 이벤트를 생성/발행(publish)하고, 이를 수신(subscribe)해야 할 때 이용함 |
| 상태(State) | - 객체의 상태에 따라 동일한 동작을 다르게 처리해야 할 때 사용
- 객체 상태를 캡슐화하고 이를 참조하는 방식으로 처리 |
| 전략(Strategy) | - 동일한 계열의 알고리즘들을 개별적으로 캡슐화함 → 알고리즘을 상호 교환할 수 있게 정의함
- 클라이언트는 독립적으로 원하는 알고리즘을 선택하여 사용할 수 있음
- 클라이언트에 영향 없이 알고리즘 변경 가능 |
| 템플릿 메소드
(Template Method) | - 상위 클래스에서 골격을 정의 → 하위 클래스에서 세부 처리를 구체화하는 구조의 패턴
- 유사한 서브 클래스를 묶어 공통된 내용을 상위 클래스에서 정의함
- 코드의 양을 줄이고 유지보수를 쉽게 해줌 |
| 방문자(Visitor) | - 각 클래스들의 데이터 구조에서 처리 기능을 분리 → 별도의 클래스로 구성
- 분리된 처리 기능은 각 클래스를 방문(Visit)하여 수행함 |

### 행위 패턴 11가지 쉽게 외우기

- 책임 연쇄 : 위에서 쏟아지는 물을 여러 물받이가 `연속(Chain)해서 나눠 받는(Responsibility) 물레방아`
- 커맨드 : 각종 `명령어(Command)` 를 하나로 합쳐둔 것
- 인터프리터 : `언어 번역가(interpreter)`
- 반복자 : `같은 명령의 반복(Iterator)` (ex. 음악파일의 다음 곡 재생)
- 중재자 : 물품 매매를 `중개해주는(Mediator) 인터넷 사이트`
- 메멘토 : 기억 속의 `그 때(Memento)로 돌아가는 것`
- 옵서버 : 변화를 `지켜보고(Observer)` 알려주는 것
- 상태 : 환자의 `상태(State)에 따라` 치료방법이 다른 것
- 전략 : 여러 전략들을 정하고, 필요할 때 `원하는 전략(Strategy)`을 선택하여 쓰는 것
- 템플릿 메소드 : 세모/네모/원을 그리는 `방법(Method)` 을 도형이라는 하나의 큰 `틀(Template)로 묶는 것`
- 방문자 : 하나의 프로젝트를 위해 여러 부서를 번갈아가며 `방문(Visit)` 하는 것

## 💬 Comment